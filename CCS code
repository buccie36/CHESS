#include <msp430.h>
#include <stdint.h>

// SPI Pins: P2.0 = DIN, P2.1 = CLK, P2.2 = LOAD
#define DATA_PIN  BIT0
#define CLK_PIN   BIT1
#define LOAD_PIN  BIT2

#define DATA_PORT P2OUT
#define CLK_PORT  P2OUT
#define LOAD_PORT P2OUT

#define DATA_DIR  P2DIR
#define CLK_DIR   P2DIR
#define LOAD_DIR  P2DIR

#define DATA_HIGH()  (DATA_PORT |= DATA_PIN)
#define DATA_LOW()   (DATA_PORT &= ~DATA_PIN)
#define CLK_HIGH()   (CLK_PORT |= CLK_PIN)
#define CLK_LOW()    (CLK_PORT &= ~CLK_PIN)
#define LOAD_HIGH()  (LOAD_PORT |= LOAD_PIN)
#define LOAD_LOW()   (LOAD_PORT &= ~LOAD_PIN)

volatile uint8_t matrix_data[8];
volatile uint8_t byte_index = 0;
volatile uint8_t receiving_frame = 0;

void shortDelay(void) {
    __delay_cycles(100);
}

void sendByte(uint8_t address, uint8_t data) {
    int i;  // Declare loop variable here

    for (i = 7; i >= 0; i--) {
        if (address & (1 << i)) {
            DATA_HIGH();
        } else {
            DATA_LOW();
        }
        CLK_HIGH();
        shortDelay();
        CLK_LOW();
        shortDelay();
    }
    for (i = 7; i >= 0; i--) {
        if (data & (1 << i)) {
            DATA_HIGH();
        } else {
            DATA_LOW();
        }
        CLK_HIGH();
        shortDelay();
        CLK_LOW();
        shortDelay();
    }
    LOAD_HIGH();
    shortDelay();
    LOAD_LOW();
    shortDelay();
}

void sendCommand(uint8_t cmd, uint8_t value) {
    sendByte(cmd, value);
}

void initMAX7219(void) {
    sendCommand(0x0F, 0x00); // Display test off
    sendCommand(0x0C, 0x01); // Normal operation
    sendCommand(0x0B, 0x07); // Scan all 8 digits
    sendCommand(0x09, 0x00); // No decode
    sendCommand(0x0A, 0x08); // Brightness medium
}

void updateMatrix(void) {
    uint8_t i;  // Declare loop variable here

    __disable_interrupt();
    for (i = 0; i < 8; i++) {
        sendByte(i + 1, matrix_data[i]);
    }
    __enable_interrupt();
}

int main(void) {
    WDTCTL = WDTPW | WDTHOLD;   // Stop watchdog timer

    // SPI pin setup
    DATA_DIR |= DATA_PIN;
    CLK_DIR  |= CLK_PIN;
    LOAD_DIR |= LOAD_PIN;
    DATA_LOW();
    CLK_LOW();
    LOAD_LOW();

    // Unlock GPIO (for some MSP430 variants)
    PM5CTL0 &= ~LOCKLPM5;

    initMAX7219();

    // UART1 setup (P4.2 = RXD)
    UCA1CTLW0 |= UCSWRST;          // Put eUSCI in reset
    UCA1CTLW0 |= UCSSEL__SMCLK;    // SMCLK as clock source
    UCA1BRW = 104;                 // 9600 baud (assuming 1MHz SMCLK)
    UCA1MCTLW = 0xD600;            // Modulation
    P4SEL1 &= ~BIT2;
    P4SEL0 |= BIT2;                // P4.2 UART RX
    UCA1CTLW0 &= ~UCSWRST;         // Initialize eUSCI
    UCA1IE |= UCRXIE;              // Enable RX interrupt

    __enable_interrupt();

    while (1) {
        __low_power_mode_0();  // Wait for interrupts
    }
}

// UART RX ISR with frame start detection
#pragma vector=EUSCI_A1_VECTOR
__interrupt void EUSCI_A1_RX_ISR(void) {
    uint8_t val = UCA1RXBUF;
    uint8_t i;  // Declare loop variable here

    if (!receiving_frame) {
        if (val == 0xFF) {    // Start of frame byte
            receiving_frame = 1;
            byte_index = 0;
            for (i = 0; i < 8; i++) {
                matrix_data[i] = 0;
            }
        }
        return;
    }

    matrix_data[byte_index++] = val;

    if (byte_index >= 8) {
        receiving_frame = 0;
        byte_index = 0;
        updateMatrix();
    }
}
